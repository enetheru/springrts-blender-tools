# ##### BEGIN GPL LICENSE BLOCK #####
#
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software Foundation,
#  Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
#
# ##### END GPL LICENSE BLOCK #####

bl_info = {
    "name": "SpringRTS Feature Export",
    "author": "Samuel Nicholas",
    "version": (0,1),
    "blender": (2, 6, 3),
    "location": "File > Import-Export",
    "description": "Export scene to feature"
                   "",
    "warning": "",
    "wiki_url": ""
                "",
    "tracker_url": "",
    "category": "SpringRTS"}

import bpy,os,re

def write_feature_definition(context, filepath):
    print("Writing Feature Definition")
    f = open(filepath + "/features/" + os.path.basename(filepath)
        + ".lua", 'w', encoding='utf-8')
    f.write("--// Feature Definition File\n")
    f.write("--// Generated by Enetheru's Blender Export Script\n\n")
    f.write("local objectname = \""+os.path.basename(filepath)+"\"\n")
    f.write("local featureDef = {\n")

    # General
    f.write("\n--// General\n",)

    try:
        f.write("\tdescription = \""+context.scene.description+"\",\n")
    except AttributeError:
        f.write("\tdescription = \"\",\n")

    try:
        f.write("\tdamage = " + str(round(context.scene.damage,3)) + ",\n")
    except AttributeError:
        f.write("\t--damage = 0.0,\n")

    try:
        f.write("\tfeatureDead = \"" + context.scene.featureDead + "\",\n")
    except AttributeError:
        f.write("\t--featureDead = \"\",\n")

    try:
        f.write("\tindestructable = ")
        if context.scene.indestructable:
            f.write("true")
        else:
            f.write("false")
        f.write(",\n")
    except AttributeError:
        f.write("\t--indestructable = false,\n")
    
    try:
        f.write("\tflammable = ")
        if context.scene.flammable:
            f.write("true")
        else:
            f.write("false")
        f.write(",\n")
    except AttributeError:
        f.write("\t--flammable = false,\n")

    try:
        f.write("\tnoSelect = ")
        if context.scene.noSelect:
            f.write("true")
        else:
            f.write("false")
        f.write(",\n")
    except AttributeError:
        f.write("\t--noSelect = false,\n")

    try:
        f.write("\tmass = " + str(round(context.scene.mass,3)) + ",\n")
    except AttributeError:
        f.write("\t--mass = 0.4 * metal + 0.1 * damage,\n")

    try:
        f.write("\tcrushResistance = " +
            str(round(context.scene.crushResistance,3)) + ",\n")
    except AttributeError:
        f.write("\t--crushResistance = mass,\n")

    #Visual
    f.write("\n--// Visual\n",)

    # Object needs to be the same as the name of the whole project
    f.write("\tobject = \""+os.path.basename(filepath)+".obj\",\n")

    try:
        f.write("\tsmokeTime = " + str(context.scene.smokeTime) + ",\n")
    except AttributeError:
        f.write("\t--smokeTime = 300,\n")

    #Reclaim and Resource
    f.write("\n--// Reclaim & Resource\n",)

    try:
        f.write("\treclaimable = ")
        if context.scene.reclaimable:
            f.write("true")
        else:
            f.write("false")
        f.write(",\n")
    except AttributeError:
        f.write("\t--reclaimable = true,\n")

    try:
        f.write("\tautoReclaimable = ")
        if context.scene.noSelect:
            f.write("true")
        else:
            f.write("false")
        f.write(",\n")
    except AttributeError:
        f.write("\t--autoReclaimable = reclaimable,\n")

    try:
        f.write("\treclaimTime = " +
            str(round(context.scene.reclaimTime,3)) + ",\n")
    except AttributeError:
        f.write("\t--reclaimTime = (metal+energy) * 6.0,\n")

    try:
        f.write("\tmetal = " + str(round(context.scene.metal,3)) + ",\n")
    except AttributeError:
        f.write("\t--metal = 0.0,\n")

    try:
        f.write("\tenergy = " +
            str(round(context.scene.energy,3)) + ",\n")
    except AttributeError:
        f.write("\t--reclaimTime = 0.0,\n")

    try:
        f.write("\tresurrectable = ")
        if context.scene.resurrectable == 'first':
            f.write("-1")
        elif context.scene.resurrectable == 'no':
            f.write("0")
        else:
            f.write("1")
        f.write(",\n")
    except AttributeError:
        f.write("\t--resurrectable = -1,\n")

    try:
        if context.scene.geoThermal:
            f.write("\tgeoThermal = true")
        else:
            f.write("\tgeoThermal = false")
        f.write(",\n")
    except AttributeError:
        f.write("\t--geoThermal = false,\n")

    # Placement
    f.write("\n--// Placement\n",)

    try:
        f.write("\tfootprintX = " + str(context.scene.footprintX) + ",\n")
    except AttributeError:
        f.write("\t--footprintX = 1,\n")

    try:
        f.write("\tfootprintZ = " + str(context.scene.footprintZ) + ",\n")
    except AttributeError:
        f.write("\t--footprintZ = 1,\n")

    try:
        if context.scene.blocking:
            f.write("\tblocking = true")
        else:
            f.write("\tblocking = false")
        f.write(",\n")
    except AttributeError:
        f.write("\t--blocking = true,\n")
        
    try:
        if context.scene.upright:
            f.write("\tupright = true")
        else:
            f.write("\tupright = false")
        f.write(",\n")
    except AttributeError:
        f.write("\t--upright = false,\n")

    try:
        if context.scene.nodrawundergray:
            f.write("\tnodrawundergray = true")
        else:
            f.write("\tnodrawundergray = false")
        f.write(",\n")
    except AttributeError:
        f.write("\t--nodrawundergray = false,\n")

    # Collision VOlumes
    f.write("\n--// Collision Volumes\n",)

    try:
        f.write("\tcollisionVolumeType = \"" +
            context.scene.collisionVolumeType + "\",\n")
    except AttributeError:
        f.write("\tcollisionVolumeType = \"\",\n")

    try:
        f.write("\tcollisionVolumescales = {" +
            str(round(context.scene.collisionVolumeScales[0],3)) + ", " +
            str(round(context.scene.collisionVolumeScales[1],3)) + ", " +
            str(round(context.scene.collisionVolumeScales[2],3)) + "},\n")
    except AttributeError:
        f.write("\tcollisionVolumeScales = {0.0, 0.0, 0.0},\n")

    try:
        f.write("\tcollisionVolumeOffsets = {" +
            str(round(context.scene.collisionVolumeOffsets[0],3)) + ", " +
            str(round(context.scene.collisionVolumeOffsets[1],3)) + ", " +
            str(round(context.scene.collisionVolumeOffsets[2],3)) + "},\n")
    except AttributeError:
        f.write("\tcollisionVolumeOffsets = {0.0, 0.0, 0.0},\n")

    try:
        f.write("\tcollisionVolumeTest = ")
        if context.scene.collisionVolumeTest == 'continuous':
            f.write("1,\n")
        else:
            f.write("0,\n")
    except AttributeError:
        f.write("\t--collisionVolumeTest = 0,\n")

    # Finished
    f.write("}\n")
    f.write("return lowerkeys({[objectname] = featureDef})\n")
    f.close()
    return {'FINISHED'}

def write_heirarchy(node,f,level, count):
    #write object heirarchy
    count = count+1
    f.write("\t\t")
    for i in range(level):
        f.write("\t")
    f.write("[" + str(count) +"] = {\n")
    level = level + 1
    f.write("\t\t")
    for i in range(level):
        f.write("\t")
    if node.name == node.data.name:
        f.write("name = \"" + node.name + "\",\n")
    else:
        f.write("name = \"" + node.name + "_"
            + node.data.name + "\",\n")
    f.write("\t\t")
    for i in range(level):
        f.write("\t")
    f.write("offset = {" 
           + str(round(node.location.x,3)) + ", " 
           + str(round(node.location.y,3)) + ", " 
           + str(round(node.location.z,3)) + "},\n")
    #now do the children
    for j in node.children:
        count = write_heirarchy(j, f, level, count)
    level = level - 1
    f.write("\t\t")
    for i in range(level):
        f.write("\t")
    f.write("},\n")
    return count
    

def write_obj3d_stuff(context, filepath):
    #Preparing Scene for export
    for k in bpy.data.objects:
        k.name = re.sub('\.','_',k.name)
        k.data.name = re.sub('\.','_',k.data.name)

    #Get the root node
    try:
        root_node = bpy.data.objects[context.scene.root]
    except:
        print("no root node defined")
    #FIXME
    #Invert on y axis uv coordinates
    #So far i have no idea how to do this, so i'm going to leave it for now
    print("Dont forget to invert the UV Map before exporting or at least"
        "mirror your image in the Y direction")

    #export obj file
    print("Exporting mesh to obj format")
    bpy.ops.export_scene.obj(
        filepath=filepath+"/objects3d/"+os.path.basename(filepath)+".obj",
        use_normals = True,
        use_materials = False,
        use_triangles = True)
    #FIXME
    #If i had inverted the UV Map i would uninvert it here returning the
    #scene to normal
    #
    #write object heirarchy
    print("Writing Feature Definition")
    f = open(filepath + "/objects3d/" + os.path.basename(filepath)
        + ".lua", 'w', encoding='utf-8')
    f.write("--// Object Heirarchy File\n")
    f.write("--// Generated by Enetheru's Blender Export Script\n\n")
    f.write(os.path.basename(filepath)+" = {\n")
    f.write("\tpieces = {\n")
    numpieces = write_heirarchy(root_node,f,0,0)
    f.write("\t},\n")

    #radius
    #FIXME really rough
    f.write("\tradius = "+str(round(root_node.dimensions.z/2.0,3))+",\n")

    #height
    #FIXME really rough
    f.write("\theight = "+str(round(root_node.dimensions.z,3))+",\n")

    #midpos
    f.write("\tmidpos = {0.0, 0.0, 0.0},\n")

    # textures
    f.write("\t--tex1 = \""+ "texture goes here" +"\",\n")
    f.write("\t--tex2 = \""+ "texture goes here" +"\",\n")

    # numpieces
    f.write("\tnumpieces = " + str(numpieces) + ",\n")

    #finish
    f.write("\n}\nreturn "+os.path.basename(filepath))
    f.close()
    return {'FINISHED'}

def write_images(context, filepath):
    #FIXME
    #will need to figure out what to be bothered with here as there are two
    #textures that may need exporting to acceptable formats, or whether a 
    #baked render or something else is needed, at the moment however simply
    #copying the textures you are using the appropriate folder will be all
    #thats necessary to complete
    return {'FINISHED'}

def write_some_data(context, filepath):
    print("Creating Directory Structure")
    #create base directory
    os.makedirs(filepath+"/features",exist_ok=True)
    os.makedirs(filepath+"/objects3d",exist_ok=True)
    os.makedirs(filepath+"/unittextures",exist_ok=True)

    # Write features definition
    write_feature_definition(context, filepath)
    # write obj3d stuff
    write_obj3d_stuff(context, filepath)
    # write images
    write_images(context, filepath)
    return {'FINISHED'}


# ExportHelper is a helper class, defines filename and
# invoke() function which calls the file selector.
from bpy_extras.io_utils import ExportHelper
from bpy.props import StringProperty, BoolProperty, EnumProperty
from bpy.types import Operator


class ExportSomeData(Operator, ExportHelper):
    """Export scene to springrts feature structures"""
    bl_idname = "export_springrts.feature"  # important since its how bpy.ops.import_test.some_data is constructed
    bl_label = "Export SpringRTS Feature"

    # ExportHelper mixin class uses this
    filename_ext = ""

    filter_glob = StringProperty(
            default="*.*",
            options={'HIDDEN'},
            )

    # List of operator properties, the attributes will be assigned
    # to the class instance from the operator settings before calling.

    def execute(self, context):
        return write_some_data(context, self.filepath)


# Only needed if you want to add into a dynamic menu
def menu_func_export(self, context):
    self.layout.operator(ExportSomeData.bl_idname, text="SpringRTS Feature")


def register():
    bpy.utils.register_class(ExportSomeData)
    bpy.types.INFO_MT_file_export.append(menu_func_export)


def unregister():
    bpy.utils.unregister_class(ExportSomeData)
    bpy.types.INFO_MT_file_export.remove(menu_func_export)


if __name__ == "__main__":
    register()
