# ##### BEGIN GPL LICENSE BLOCK #####
#
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software Foundation,
#  Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
#
# ##### END GPL LICENSE BLOCK #####

import bpy,os,re

def write_def(context, filepath):
    print("Writing Feature Definition")
    f = open(filepath + "/features/" + os.path.basename(filepath)
        + ".lua", 'w', encoding='utf-8')
    f.write("--// Feature Definition File\n")
    f.write("--// Generated by Enetheru's Blender Export Script\n\n")
    f.write("local objectname = \"%s\"\n" % os.path.basename(filepath))
    f.write("local featureDef = {\n")

    # General
    f.write("\n--// General\n")

    try:
        f.write("\tdescription = \"%s\",\n" % context.scene.description)
    except AttributeError:
        print("description not specified, skipping.")

    try:
        f.write("\tdamage = %.3f,\n" % context.scene.damage)
    except AttributeError:
        print("damage not specified, skipping.")

    try:
        f.write("\tfeatureDead = \"%s\",\n" % context.scene.featureDead)
    except AttributeError:
        print("featureDead not specified, skipping.")

    try:
        f.write("\tindestructable = %s,\n" % str(context.scene.indestructable).lower())
    except AttributeError:
        print("indestructable not specified, skipping.")
    
    try:
        f.write("\tflammable = %s,\n" % str(context.scene.flammable).lower())
    except AttributeError:
        print("flammable not specified, skipping.")

    try:
        f.write("\tnoSelect = %s,\n" % str(context.scene.noSelect).lower())
    except AttributeError:
        print("noSelect not specified, skipping.")

    try:
        f.write("\tmass = %.3f,\n" % context.scene.mass)
    except AttributeError:
        print("mass not specified, skipping.")

    try:
        f.write("\tcrushResistance = %.3f,\n" % context.scene.crushResistance)
    except AttributeError:
        print("crushResistance not specified, skipping.")

    #Visual
    f.write("\n--// Visual\n")

    # Object needs to be the same as the name of the whole project
    f.write("\tobject = \"%s.obj\",\n" % os.path.basename(filepath))

    try:
        f.write("\tsmokeTime = %i,\n" % context.scene.smokeTime)
    except AttributeError:
        print("smokeTime not specified, skipping.")

    #Reclaim and Resource
    f.write("\n--// Reclaim & Resource\n")

    try:
        f.write("\treclaimable = %s,\n" % str(context.scene.reclaimable).lower())
    except AttributeError:
        print("reclaimable not specified, skipping.")

    try:
        f.write("\tautoReclaimable = %s,\n" % str(context.scene.noSelect).lower())
    except AttributeError:
        print("autoReclaim not specified, skipping.")

    try:
        f.write("\treclaimTime = %.3f,\n" % context.scene.reclaimTime)
    except AttributeError:
        print("reclaimTime not specified, skipping.")

    try:
        f.write("\tmetal = %.3f,\n" % context.scene.metal)
    except AttributeError:
        print("metal not specified, skipping.")

    try:
        f.write("\tenergy = %.3f,\n" % context.scene.energy)
    except AttributeError:
        print("energy not specified, skipping.")

    try:
        f.write("\tresurrectable = ")
        if context.scene.resurrectable == 'first':
            f.write("-1")
        elif context.scene.resurrectable == 'no':
            f.write("0")
        else:
            f.write("1")
        f.write(",\n")
    except AttributeError:
        print("resurrectable not specified, skipping.")

    try:
        f.write("\tgeoThermal = %s,\n" % str(context.scene.geoThermal).lower())
    except AttributeError:
        print("geoThermal not specified, skipping.")

    # Placement
    f.write("\n--// Placement\n",)

    try:
        f.write("\tfootprintX = %i,\n" % context.scene.footprintX)
    except AttributeError:
        print("footprintX not specified, skipping.")

    try:
        f.write("\tfootprintZ = %i,\n" % context.scene.footprintZ)
    except AttributeError:
        print("footprintY not specified, skipping.")

    try:
        f.write("\tblocking = %s,\n" % str(context.scene.blocking).lower())
    except AttributeError:
        print("blocking not specified, skipping.")
        
    try:
        f.write("\tupright = %s,\n" % str(context.scene.upright).lower())
    except AttributeError:
        print("upright not specified, skipping.")

    try:
        f.write("\tfloating = %s,\n" % str(context.scene.floating).lower())
    except AttributeError:
        print("floating not specified, skipping.")

    # Collision VOlumes
    f.write("\n--// Collision Volumes\n",)

    try:
        if context.scene.collisionVolumeType == "SME_box":
            ctype = "box"
        elif context.scene.collisionVolumeType == "SME_ellipsoid":
            ctype = "ellipse"
        elif context.scene.collisionVolumeType == "SME_cylX":
            ctype = "cylX"
        elif context.scene.collisionVolumeType == "SME_cylY":
            ctype = "cylY"
        elif context.scene.collisionVolumeType == "SME_cylZ":
            ctype = "cylZ"
    except AttributeError:
        print("collisionVolumeType not specified, skipping.")
    else:
        f.write("\tcollisionVolumeType = \"%s\",\n" % ctype)

    try:
        f.write("\tcollisionVolumescales = {%.3f, %.3f, %.3f},\n" % (
            context.scene.collisionVolumeScales[0],
            context.scene.collisionVolumeScales[1],
            context.scene.collisionVolumeScales[2]))
    except AttributeError:
        print("collisionVolumeScales not specified, skipping.")

    try:
        f.write("\tcollisionVolumeOffsets = {%.3f, %.3f, %.3f},\n" % (
            context.scene.collisionVolumeOffsets[0],
            context.scene.collisionVolumeOffsets[1],
            context.scene.collisionVolumeOffsets[2],))
    except AttributeError:
        print("collisionVolumeOffsets not specified, skipping.")

    # Finished
    f.write("}\n")
    f.write("return lowerkeys({[objectname] = featureDef})\n")
    f.close()
    return {'FINISHED'}

def write_heirarchy(node,f,level, count):
    #keep track of how manu objects
    count = count+1

    #Write piece name and opening brackets
    f.write("\t" * (level + 2))
    if node.name == node.data.name:
        f.write("%s = {\n" % node.name.lower())
    else:
        f.write("%s_%s = {\n" % (node.name.lower(), node.data.name.lower()))
    level = level + 1
    
    #Write offset
    f.write("\t" * (level + 2))
    f.write("offset = {%.3f, %.3f, %.3f},\n" % (
        node.matrix_local[0][3],
        node.matrix_local[2][3],
        node.matrix_local[1][3]*(-1)))

    #recursively do the children
    for j in node.children:
        count = write_heirarchy(j, f, level, count)
    level = level - 1

    #closing brackets
    for i in range(level+2):
        f.write("\t")
    f.write("},\n")

    return count
    

def write_obj(context, filepath):
    #Preparing Scene for export
    for k in bpy.data.objects:
        k.name = re.sub('\.','_',k.name)
        k.data.name = re.sub('\.','_',k.data.name)

    #Get the root node
    try:
        root_node = bpy.data.objects[context.scene.root]
    except:
        print("no root node defined")
    #So far i have no idea how to do this, so i'm going to leave it for now
    print("Dont forget to invert the UV Map before exporting or at least"
        "mirror your image in the Y direction")

    #export obj file
    print("Exporting mesh to obj format")
    bpy.ops.export_scene.obj(
        filepath=filepath+"/objects3d/"+os.path.basename(filepath)+".obj",
        use_normals = True,
        use_materials = False,
        use_triangles = True)

    #write object heirarchy
    print("Writing Feature Definition")
    f = open(filepath + "/objects3d/" + os.path.basename(filepath)
        + ".lua", 'w', encoding='utf-8')
    f.write("--// Object Heirarchy File\n")
    f.write("--// Generated by Enetheru's Blender Export Script\n\n")
    f.write(os.path.basename(filepath)+" = {\n")
    f.write("\tpieces = {\n")
    numpieces = write_heirarchy(root_node,f,0,0)
    f.write("\t},\n")

    #radius
    try:
        f.write("\tradius = %.3f,\n" %context.scene.radius)
    except AttributeError:
        print("Damage not specified, skipping.")

    #height
#    try:
#        f.write("\theight = " + str(context.scene.height) + ",\n")
#    except AttributeError:
        #FIXME really rough, it doesnt take into account the object heirarchy
        #auto calculate
#        f.write("\theight = "+str(round(root_node.dimensions.z,3))+",\n")

    #midpos
    try:
        f.write("\tmidpos = {%.3f, %.3f, %.3f},\n" % (
            context.scene.midpos[0] * (-1),
            context.scene.midpos[1],
            context.scene.midpos[2]))
    except AttributeError:
        print("Damage not specified, skipping.")

    # textures
    f.write("\ttex1 = \"%s\",\n" % context.scene.tex1)
    f.write("\t--tex2 = \"%s\",\n" % context.scene.tex2)

    # numpieces
    f.write("\tnumpieces = %i,\n" %numpieces)
    f.write("\tglobalvertexoffsets = true,\n")
    f.write("\tlocalpieceoffsets = true,\n")

    #finish
    f.write("\n}\nreturn "+os.path.basename(filepath))
    f.close()
    return {'FINISHED'}

def write_images(context, filepath):
    #FIXME
    #will need to figure out what to be bothered with here as there are two
    #textures that may need exporting to acceptable formats, or whether a 
    #baked render or something else is needed, at the moment however simply
    #copying the textures you are using the appropriate folder will be all
    #thats necessary to complete
    return {'FINISHED'}

def export(context, filepath):
    # check if root node exists
    if not context.scene.root in context.scene.objects:
        raise RuntimeError("You need to make sure to set the root node")
        return {'FINISHED'}

    # Check if UV Maps are defined for all objects
    if check_uvmaps(context.scene.objects[context.scene.root]):
        raise RuntimeError("not all objects have UV Maps defined")
        return {'FINISHED'}

    print("Creating Directory Structure")
    #create base directory
    os.makedirs(filepath+"/features",exist_ok=True)
    os.makedirs(filepath+"/objects3d",exist_ok=True)
    os.makedirs(filepath+"/unittextures",exist_ok=True)

    # Write features definition
    write_def(context, filepath)
    # write obj3d stuff
    write_obj(context, filepath)
    # write images
    write_images(context, filepath)
    return {'FINISHED'}

def check_uvmaps(node):
    nouvmap = False
    if node.data.uv_textures.active == None:
        print("%s has no uv map defined\n" % node.data.name)
        nouvmap = True

    for j in node.children:
        childuvmap = check_uvmaps(j)
        nouvmap = nouvmap or childuvmap

    return nouvmap
