# ##### BEGIN GPL LICENSE BLOCK #####
#
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software Foundation,
#  Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
#
# ##### END GPL LICENSE BLOCK #####

import bpy,os,re
    
def export(self, context):
    # Get spring feature properties
    obj = bpy.context.object
    sfp = obj.sfp

    # get base directory
    dirname = os.path.dirname(self.filepath)
    print("LOG: exporting %s" % obj.name)
    if obj.name == None or obj.name == '':
        obj.name = os.path.basename(self.filepath)

    selection = context.active_object

    # prepare
    pre_recurse(self, context, context.active_object)
    context.scene.objects.active = selection
    selection.select = True
    # Write features definition
    write_featuredef(self, context, dirname)
    context.scene.objects.active = selection
    selection.select = True
    # Write mesh hierarchy
    write_meshdef(self, context, dirname)
    context.scene.objects.active = selection
    selection.select = True
    # write obj stuff
    write_dae(self, context, dirname)
    context.scene.objects.active = selection
    selection.select = True
    # Image
    copy_images(self, context, dirname)
    context.scene.objects.active = selection
    selection.select = True
    # cleanup
    post(self, context)

    return {'FINISHED'}

def pre_recurse(self, context, node):
    # if not mesh skip
    if node.type != 'MESH': return

    # Get spring feature properties
    obj = bpy.context.object
    sfp = obj.sfp

    # Deselect all objects
    bpy.ops.object.select_all(action='DESELECT')

    # select the root node and make it active.
    node.select = True
    bpy.context.scene.objects.active = node

    # rename objects to comply with object loading in springrts
    node.name = re.sub('\.','_',node.name).lower()
    node.data.name = re.sub('\.','_',node.data.name).lower()

    # create UV maps
    if node.data.uv_textures.active == None:
        print("WARN: no UV coordinates specified for %s, Creating" % node.name)
        bpy.ops.object.mode_set(mode='EDIT')
        bpy.ops.uv.unwrap()
        bpy.ops.object.mode_set(toggle=True)

    # invert UV Maps
    if self.invertUV:
        for uvloop in node.data.uv_layers.active.data: uvloop.uv[1] = uvloop.uv[1] * -1 + 1
    
    #recurse through children
    for i in node.children: pre_recurse(self, context, i)

def write_featuredef(self, context, dirname):
    print("LOG: Writing Feature Definition")
    # Get spring feature properties
    obj = bpy.context.object
    sfp = obj.sfp


    filepath = dirname + "/features/" + obj.name + ".lua"

    if not self.overwrite:
        if os.path.isfile(filepath):
            print("WARN: %s exists, skipping." % filepath)
            return

    #creating directory
    os.makedirs(dirname+"/features",exist_ok=True)

    f = open(filepath, 'w', encoding='utf-8')
    f.write("--// Feature Definition File\n")
    f.write("--// Generated by Enetheru's Blender Export Script\n\n")
    f.write("local objectname = \"%s\"\n" % obj.name)
    f.write("local featureDef = {\n")

    # General
    f.write("\n--// General\n")

    try:
        f.write("\tdescription = \"%s\",\n" % sfp.description)
    except AttributeError:
        print("WARN: description not specified, skipping.")

    try:
        f.write("\tdamage = %.3f,\n" % sfp.damage)
    except AttributeError:
        print("WARN: damage not specified, skipping.")

    try:
        f.write("\tfeatureDead = \"%s\",\n" % sfp.featureDead)
    except AttributeError:
        print("WARN: featureDead not specified, skipping.")

    try:
        f.write("\tindestructable = %s,\n" % str(sfp.indestructable).lower())
    except AttributeError:
        print("WARN: indestructable not specified, skipping.")
    
    try:
        f.write("\tflammable = %s,\n" % str(sfp.flammable).lower())
    except AttributeError:
        print("WARN: flammable not specified, skipping.")

    try:
        f.write("\tnoSelect = %s,\n" % str(sfp.noSelect).lower())
    except AttributeError:
        print("WARN: noSelect not specified, skipping.")

    try:
        f.write("\tmass = %.3f,\n" % sfp.mass)
    except AttributeError:
        print("WARN: mass not specified, skipping.")

    try:
        f.write("\tcrushResistance = %.3f,\n" % sfp.crushResistance)
    except AttributeError:
        print("WARN: crushResistance not specified, skipping.")

    #Visual
    f.write("\n--// Visual\n")

    # Object needs to be the same as the name of the whole project
    f.write("\tobject = \"%s.dae\",\n" % obj.name)

    try:
        f.write("\tsmokeTime = %i,\n" % sfp.smokeTime)
    except AttributeError:
        print("WARN: smokeTime not specified, skipping.")

    #Reclaim and Resource
    f.write("\n--// Reclaim & Resource\n")

    try:
        f.write("\treclaimable = %s,\n" % str(sfp.reclaimable).lower())
    except AttributeError:
        print("WARN: reclaimable not specified, skipping.")

    try:
        f.write("\tautoReclaimable = %s,\n" % str(sfp.autoReclaimable).lower())
    except AttributeError:
        print("WARN: autoReclaim not specified, skipping.")

    try:
        f.write("\treclaimTime = %.3f,\n" % sfp.reclaimTime)
    except AttributeError:
        print("WARN: reclaimTime not specified, skipping.")

    try:
        f.write("\tmetal = %.3f,\n" % sfp.metal)
    except AttributeError:
        print("WARN: metal not specified, skipping.")

    try:
        f.write("\tenergy = %.3f,\n" % sfp.energy)
    except AttributeError:
        print("WARN: energy not specified, skipping.")

    try:
        f.write("\tresurrectable = ")
        if sfp.resurrectable == 'first':
            f.write("-1")
        elif sfp.resurrectable == 'no':
            f.write("0")
        else:
            f.write("1")
        f.write(",\n")
    except AttributeError:
        print("WARN: resurrectable not specified, skipping.")

    try:
        f.write("\tgeoThermal = %s,\n" % str(sfp.geoThermal).lower())
    except AttributeError:
        print("WARN: geoThermal not specified, skipping.")

    # Placement
    f.write("\n--// Placement\n",)

    try:
        f.write("\tfootprintX = %i,\n" % sfp.footprintX)
    except AttributeError:
        print("WARN: footprintX not specified, skipping.")

    try:
        f.write("\tfootprintZ = %i,\n" % sfp.footprintZ)
    except AttributeError:
        print("WARN: footprintY not specified, skipping.")

    try:
        f.write("\tblocking = %s,\n" % str(sfp.blocking).lower())
    except AttributeError:
        print("WARN: blocking not specified, skipping.")
        
    try:
        f.write("\tupright = %s,\n" % str(sfp.upright).lower())
    except AttributeError:
        print("WARN: upright not specified, skipping.")

    try:
        f.write("\tfloating = %s,\n" % str(sfp.floating).lower())
    except AttributeError:
        print("WARN: floating not specified, skipping.")

    # Collision VOlumes
    f.write("\n--// Collision Volumes\n",)

    try:
        if sfp.collisionVolumeType == "SME_box":
            ctype = "box"
        elif sfp.collisionVolumeType == "SME_ellipsoid":
            ctype = "ellipse"
        elif sfp.collisionVolumeType == "SME_cylX":
            ctype = "cylX"
        elif sfp.collisionVolumeType == "SME_cylY":
            ctype = "cylY"
        elif sfp.collisionVolumeType == "SME_cylZ":
            ctype = "cylZ"
    except AttributeError:
        print("WARN: collisionVolumeType not specified, skipping.")
    else:
        f.write("\tcollisionVolumeType = \"%s\",\n" % ctype)

    try:
        f.write("\tcollisionVolumeScales = {%.3f, %.3f, %.3f},\n" % (
            sfp.collisionVolumeScales[0],
            sfp.collisionVolumeScales[1],
            sfp.collisionVolumeScales[2]))
    except AttributeError:
        print("WARN: collisionVolumeScales not specified, skipping.")

    try:
        f.write("\tcollisionVolumeOffsets = {%.3f, %.3f, %.3f},\n" % (
            sfp.collisionVolumeOffsets[0],
            sfp.collisionVolumeOffsets[1],
            sfp.collisionVolumeOffsets[2],))
    except AttributeError:
        print("WARN: collisionVolumeOffsets not specified, skipping.")

    # Finished
    f.write("}\n")
    f.write("return lowerkeys({[objectname] = featureDef})\n")
    f.close()
    return {'FINISHED'}

def write_meshdef(self, context, dirname):
    print("LOG: Writing Feature Definition")
    # Get spring feature properties
    obj = bpy.context.object
    sfp = obj.sfp

    filepath = dirname + "/objects3d/" + obj.name + ".lua"

    if not self.overwrite:
        if os.path.isfile(filepath):
            print("WARN: %s exists, skipping." % filepath)
            return

    #creating directory
    os.makedirs(dirname+"/objects3d",exist_ok=True)

    f = open(filepath, 'w', encoding='utf-8')
    f.write("--// Object Heirarchy File\n")
    f.write("--// Generated by Enetheru's Blender Export Script\n\n")
    f.write(obj.name + " = {\n")

# this is older code for when i used to export as obj format
#    f.write("\tpieces = {\n")
#    numpieces = write_mesh_hierarchy(context.active_object, 0, 0, f)
#    f.write("\t},\n")

    #radius
    try:
        f.write("\tradius = %.3f,\n" %sfp.radius)
    except AttributeError:
        print("WARN: Damage not specified, skipping.")

    #midpos
    try:
        f.write("\tmidpos = {%.3f, %.3f, %.3f},\n" % (
            sfp.midpos[0] * (-1),
            sfp.midpos[1],
            sfp.midpos[2]))
    except AttributeError:
        print("WARN: Damage not specified, skipping.")

    # textures
#    if not(sfp.tex1 == None or sfp.tex1 == ''):
#        texture1 = os.path.basename(bpy.data.images[sfp.tex1].filepath)
#        f.write("\ttex1 = \"%s\",\n" % texture1)
    f.write("\ttex1 = \"%s_tex1.dds\",\n" % obj.name)
    f.write("\ttex2 = \"%s_tex1.dds\",\n" % obj.name)

#    if not(sfp.tex2 == None or sfp.tex2 == ''):
#        texture2 = os.path.basename(bpy.data.images[sfp.tex2].filepath)
#        f.write("\ttex2 = \"%s\",\n" % texture2)

    # numpieces
#    f.write("\tnumpieces = %i,\n" %numpieces)
#    f.write("\tglobalvertexoffsets = true,\n")
#    f.write("\tlocalpieceoffsets = false,\n")

    #finish
    f.write("\n}\nreturn " + obj.name)
    f.close()

# this is no longer used. was for hen i was writing obj format.
def write_mesh_hierarchy(node, level, count, f):
    # Get spring feature properties
    sfp = bpy.context.object.sfp

    # if not mesh skip
    if node.type != 'MESH': return count
    #keep track of how manu objects
    count = count+1

    #Write piece name and opening brackets
    f.write("\t" * (level + 2))
    if node.name == node.data.name:
        f.write("%s = {\n" % node.name)
    else:
        f.write("%s_%s = {\n" % (node.name, node.data.name))
    level = level + 1
    
    #Write offset
    f.write("\t" * (level + 2))
    f.write("offset = {%.3f, %.3f, %.3f},\n" % (
        node.matrix_world[0][3],
        node.matrix_world[2][3],
        node.matrix_world[1][3] * -1))

    #recursively do the children
    for j in node.children:
        count = write_mesh_hierarchy(j, level, count, f)
    level = level - 1

    #closing brackets
    for i in range(level+2):
        f.write("\t")
    f.write("},\n")

    return count

def write_obj(self, context, dirname):
    print("LOG: Exporting mesh to obj format")
    # Get spring feature properties
    obj = bpy.context.object
    sfp = bpy.context.object.sfp

    filepath = dirname + "/objects3d/" + obj.name + ".obj"

    if not self.overwrite:
        if os.path.isfile(filepath):
            print("WARN: %s exists, skipping." % filepath)
            return

    print(context.active_object)
    #select all the children of the root node.
    for i in range(256):
        bpy.ops.object.select_hierarchy(direction='CHILD', extend=True)

    #export obj file
    bpy.ops.export_scene.obj(
        filepath=filepath,
        use_selection = True,
        use_normals = True,
        use_materials = False,
        use_triangles = True)

def write_dae(self, context, dirname):
    print("LOG: Exporting mesh to collada format")
    # Get spring feature properties
    obj = bpy.context.object
    sfp = bpy.context.object.sfp

    filepath = dirname + "/objects3d/" + obj.name + ".dae"

    if not self.overwrite:
        if os.path.isfile(filepath):
            print("WARN: %s exists, skipping." % filepath)
            return

    print(context.active_object)
    #select all the children of the root node.
    for i in range(256):
        bpy.ops.object.select_hierarchy(direction='CHILD', extend=True)

    #export dae file
    bpy.ops.wm.collada_export(
            filepath=filepath, \
            check_existing=True, \
            #filemode=8, \
            #display_type='FILE_DEFAULTDISPLAY', \
            #apply_modifiers=False, \
            #export_mesh_type=0, \
            #export_mesh_type_selection='view', \
            selected=True, \
            include_children=True, \
            #include_armatures=False, \
            include_shapekeys=False, \
            #deform_bones_only=False, \
            #active_uv_only=False, \
            #include_uv_textures=False, \
            #include_material_textures=False, \
            #use_texture_copies=True, \
            #triangulate=True, \
            #use_object_instantiation=True, \
            sort_by_name=True, \
            )


def copy_images(self, context, dirname):
    print("LOG: Copying images to destination directory")
    # Get spring feature properties
    sfp = bpy.context.object.sfp

    #creating directory
    os.makedirs(dirname+"/unittextures",exist_ok=True)
    # Copy images
    if not(sfp.tex1 == None or sfp.tex1 == ''):
        texture1 = os.path.basename(bpy.data.images[sfp.tex1].filepath)
        filepath = dirname+"/unittextures/"+texture1
        if (not os.path.isfile(filepath)) or self.overwrite:
            bpy.data.images[sfp.tex1].save_render(filepath)
        else:
            print("WARN: %s exists, skipping." % filepath)

    if not(sfp.tex2 == None or sfp.tex2 == ''):
        texture2 = os.path.basename(bpy.data.images[sfp.tex2].filepath)
        filepath = dirname+"/unittextures/"+texture2
        if (not os.path.isfile(filepath)) or self.overwrite:
            bpy.data.images[sfp.tex2].save_render(filepath)
        else:
            print("WARN: %s exists, skipping." % filepath)

def post(self, context):
    # Get spring feature properties
    sfp = bpy.context.object.sfp
    post_recurse(self, context, context.active_object)
    print("LOG: SpringRTS Feature Export Complete")

def post_recurse(self, context, node):
    # if not mesh skip
    if node.type != 'MESH': return count

    # Deselect all objects
    bpy.ops.object.select_all(action='DESELECT')

    # select the root node and make it active.
    node.select = True
    bpy.context.scene.objects.active = node

    if self.invertUV:
        for uvloop in node.data.uv_layers.active.data: uvloop.uv[1] = uvloop.uv[1] * -1 + 1

    for i in node.children: post_recurse(self, context, i)
